#!/bin/bash

# Restic Backup Script
# This script performs a backup using restic

set -exuo pipefail

# Retry configuration (templated from Ansible defaults)
RESTIC_BACKUP_RETRY_ATTEMPTS={{ restic_backup_retry_attempts }}
RESTIC_BACKUP_RETRY_BASE_SLEEP_SECONDS={{ restic_backup_retry_base_sleep_seconds }}
RESTIC_BACKUP_RETRY_MAX_SLEEP_SECONDS={{ restic_backup_retry_max_sleep_seconds }}

# Source environment file if it exists
if [ -f "{{ restic_config_dir }}/restic.env" ]; then
    source "{{ restic_config_dir }}/restic.env"
fi

# Log function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a {{ restic_log_dir }}/backup.log
}

# Track the actual backup result (not just the last command's exit code)
SCRIPT_EXIT_CODE=0

# Custom error handling - treat exit code 3 (warnings) as success
handle_exit() {
    local exit_code=${SCRIPT_EXIT_CODE}
    
    # If SCRIPT_EXIT_CODE wasn't set explicitly, use the actual exit code
    if [ $exit_code -eq 0 ]; then
        exit_code=$?
    fi
    
    # Only log if we haven't already logged the final status
    if [ $exit_code -ne 0 ] && [ $exit_code -ne 3 ]; then
        log "ERROR: Backup failed with exit code $exit_code"
    fi
    
    exit $exit_code
}

# Handle interrupts (Ctrl+C) gracefully
handle_interrupt() {
    log "âš ï¸  Backup interrupted by user (SIGINT/SIGTERM)"
    SCRIPT_EXIT_CODE=130
    exit 130
}

trap 'handle_exit' EXIT
trap 'handle_interrupt' INT TERM

is_retryable_restic_failure() {
    # Heuristics for transient failures (repo lock contention / network hiccups).
    # We intentionally keep this conservative: only retry on patterns we see in the wild.
    local file="$1"
    grep -Eqi \
        -e 'repo already locked' \
        -e 'unable to create lock' \
        -e 'repository is already locked' \
        -e 'waiting up to [0-9]+s for the lock' \
        -e 'timeout' \
        -e 'TLS handshake timeout' \
        -e 'connection reset by peer' \
        -e 'temporary failure' \
        -e 'Service Unavailable|503' \
        -e 'SlowDown' \
        -e 'RequestCanceled' \
        -e 'EOF' \
        -e 'The specified key does not exist' \
        -e 'Load.*returned error.*retrying' \
        "$file"
}

sleep_with_backoff() {
    local attempt="$1"  # 1-based
    local base="${RESTIC_BACKUP_RETRY_BASE_SLEEP_SECONDS}"
    local max="${RESTIC_BACKUP_RETRY_MAX_SLEEP_SECONDS}"
    local sleep_seconds=$(( base * attempt ))
    if [ "$sleep_seconds" -gt "$max" ]; then
        sleep_seconds="$max"
    fi
    log "â³ Sleeping ${sleep_seconds}s before retry (attempt ${attempt}/${RESTIC_BACKUP_RETRY_ATTEMPTS})"
    sleep "$sleep_seconds"
}

log "Starting restic backup"

{% if restic_postgresql_backup_enabled | bool %}
# Run PostgreSQL dumps before backup
log "Running PostgreSQL database dumps"
"{{ restic_scripts_dir }}/pg_dump.sh"

# Count successful database backups
DB_BACKUP_COUNT=$(find "{{ restic_postgresql_backup_dir }}" -name "*.sql" -type f -mmin -5 2>/dev/null | wc -l)
DB_BACKUP_COUNT=${DB_BACKUP_COUNT:-0}
log "ğŸ“Š Database backups completed: $DB_BACKUP_COUNT database(s) dumped"
{% endif %}

# Test S3 connectivity before backup
log "ğŸ”— Testing S3 repository connectivity..."
set +e
SNAPSHOT_TEST_OUTPUT=$(restic snapshots --latest 1 2>&1)
SNAPSHOT_TEST_EXIT=$?
set -e
if [ $SNAPSHOT_TEST_EXIT -eq 0 ] || echo "$SNAPSHOT_TEST_OUTPUT" | grep -q "snapshot\|repository.*opened"; then
    log "âœ… S3 repository is accessible"
else
    log "âš ï¸  S3 repository connection issue - proceeding with backup attempt"
fi

# Create exclude file with proper permissions
EXCLUDE_FILE="$(mktemp -t restic-exclude.XXXXXX)"
cat > "$EXCLUDE_FILE" << EOF
{% for pattern in restic_exclude_patterns %}
{{ pattern }}
{% endfor %}
EOF

# Perform backup
# Note: Backup timing/spreading is handled by systemd timer's RandomizedDelaySec
# No need for additional random delay here
log "Running restic backup"

# Temporarily disable errexit so we can capture the restic exit code without aborting
set +e

BACKUP_EXIT_CODE=1
LATEST_SNAPSHOT="unknown"
for attempt in $(seq 1 "${RESTIC_BACKUP_RETRY_ATTEMPTS}"); do
    log "â–¶ï¸  restic backup attempt ${attempt}/${RESTIC_BACKUP_RETRY_ATTEMPTS}"
    RESTIC_STDERR_TMP="$(mktemp -t restic-backup-stderr.XXXXXX)"
    RESTIC_STDOUT_TMP="$(mktemp -t restic-backup-stdout.XXXXXX)"

    restic backup \
        --verbose \
        --exclude-file="$EXCLUDE_FILE" \
        {% for path in restic_backup_paths -%}
        "{{ path }}" \
        {% endfor -%}
        {% if restic_postgresql_backup_enabled | bool -%}
        {% for path in restic_postgresql_backup_paths -%}
        "{{ path }}" \
        {% endfor -%}
        {% endif %} \
        2> >(tee -a "$RESTIC_STDERR_TMP" >&2) | tee "$RESTIC_STDOUT_TMP"

    BACKUP_EXIT_CODE=$?

    # Extract snapshot ID and data transferred from backup output
    if [ "$BACKUP_EXIT_CODE" -eq 0 ] || [ "$BACKUP_EXIT_CODE" -eq 3 ]; then
        LATEST_SNAPSHOT=$(grep -o 'snapshot [a-f0-9]\{8\} saved' "$RESTIC_STDOUT_TMP" | awk '{print $2}' || echo "unknown")
        # Extract "Added to the repository: X KiB/GiB" or "Added to the repo: X KiB/GiB"
        DATA_TRANSFERRED=$(grep -oE 'Added to the (repository|repo): [0-9.]+ [KMGT]?i?B' "$RESTIC_STDOUT_TMP" | sed 's/Added to the \(repository\|repo\): //' || echo "0 B")
    fi

    # Treat warnings (exit 3) as success for systemd.
    if [ "$BACKUP_EXIT_CODE" -eq 0 ] || [ "$BACKUP_EXIT_CODE" -eq 3 ]; then
        rm -f "$RESTIC_STDERR_TMP" "$RESTIC_STDOUT_TMP" || true
        break
    fi

    if is_retryable_restic_failure "$RESTIC_STDERR_TMP" && [ "$attempt" -lt "${RESTIC_BACKUP_RETRY_ATTEMPTS}" ]; then
        log "âš ï¸  Retryable restic failure detected (exit code $BACKUP_EXIT_CODE)"
        rm -f "$RESTIC_STDERR_TMP" "$RESTIC_STDOUT_TMP" || true
        sleep_with_backoff "$attempt"
        continue
    fi

    # Not retryable or last attempt
    rm -f "$RESTIC_STDERR_TMP" "$RESTIC_STDOUT_TMP" || true
    break
done

# Check backup result and log S3 transfer status immediately
# Re-enable errexit for the remainder of the script
set -e

# Initialize DATA_TRANSFERRED if not set (shouldn't happen, but safety check)
DATA_TRANSFERRED=${DATA_TRANSFERRED:-"0 B"}

if [ $BACKUP_EXIT_CODE -eq 0 ]; then
    if [ "$DATA_TRANSFERRED" = "0 B" ]; then
        log "âœ… Backup completed successfully - snapshot created (no changes, 0 B transferred)"
    else
        log "âœ… Backup completed successfully - $DATA_TRANSFERRED transferred to S3"
    fi
elif [ $BACKUP_EXIT_CODE -eq 3 ]; then
    if [ "$DATA_TRANSFERRED" = "0 B" ]; then
        log "âš ï¸  Backup completed with warnings - snapshot created (no changes, 0 B transferred, some files skipped due to permissions)"
    else
        log "âš ï¸  Backup completed with warnings - $DATA_TRANSFERRED transferred to S3 (some files skipped due to permissions)"
    fi
else
    log "âŒ Backup failed with exit code $BACKUP_EXIT_CODE - S3 transfer may have failed"
fi

# Show backup details
log "ğŸ“Š Backup snapshot information:"
log "   ğŸ“‹ Snapshot ID: $LATEST_SNAPSHOT"
# Show snapshot count (non-fatal if it fails)
set +e
SNAPSHOT_INFO=$(restic snapshots --latest 1 --compact 2>/dev/null | tail -1)
if [ -n "$SNAPSHOT_INFO" ]; then
    log "   $SNAPSHOT_INFO"
fi
set -e

# Verify backup if enabled (non-fatal - backup already succeeded)
{% if restic_verify_backups | bool %}
log "Verifying backup"
set +e
restic check --read-data-subset=10% 2>&1 | tee -a {{ restic_log_dir }}/backup.log
CHECK_EXIT_CODE=$?
set -e
if [ $CHECK_EXIT_CODE -ne 0 ]; then
    log "âš ï¸  Verification failed (exit code $CHECK_EXIT_CODE) - this is non-fatal, backup data was transferred successfully"
else
    log "âœ… Verification completed successfully"
fi
{% endif %}

# List snapshots (non-fatal if it fails)
log "Current snapshots:"
set +e
restic snapshots --latest 10 2>&1 | tee -a {{ restic_log_dir }}/backup.log || true
set -e

# Clean up
rm -f "$EXCLUDE_FILE"

# Backup completion summary
log "ğŸ¯ BACKUP SUMMARY:"
{% if restic_postgresql_backup_enabled | bool %}
log "   ğŸ“Š Database backups: $DB_BACKUP_COUNT database(s) processed"
log "   ğŸ“ Database backup directory: {{ restic_postgresql_backup_dir }}"
{% endif %}
log "   ğŸ“¦ S3 Repository: {{ restic_repository }}"
log "   ğŸ“‹ Snapshot ID: $LATEST_SNAPSHOT"
log "   ğŸ’¾ Data transferred: $DATA_TRANSFERRED"
log "   ğŸ”„ Backup exit code: $BACKUP_EXIT_CODE"

log "Backup process completed"

# Set the final exit code for the script (backup success = script success)
# Verification failures are logged but don't fail the script since data is already backed up
SCRIPT_EXIT_CODE=$BACKUP_EXIT_CODE

# Handle final exit code for systemd
if [ $BACKUP_EXIT_CODE -eq 0 ]; then
    log "âœ… Backup completed successfully - data is safely stored in S3"
    exit 0
elif [ $BACKUP_EXIT_CODE -eq 3 ]; then
    log "âœ… Backup completed with warnings - data is safely stored in S3 (some files skipped due to permissions)"
    exit 0  # Exit with success code for systemd
else
    log "âŒ Backup failed with exit code $BACKUP_EXIT_CODE"
    exit $BACKUP_EXIT_CODE 
fi 