---
# tasks file for iptables

# Skip all firewall configuration if role disabled
- name: Check if iptables management is disabled
  ansible.builtin.debug:
    msg: "ðŸ›‘ iptables role disabled - skipping all firewall configuration"
  when: not (iptables_manage_firewall | default(true))
  tags: [always]

- name: Check if Docker role has been applied
  when: iptables_manage_firewall | default(true)
  become: true
  tags: [prereq, validate, docker, always]
  block:
    - name: Check for docker binary
      ansible.builtin.stat:
        path: /usr/bin/docker
      register: docker_binary_check
      failed_when: false

    - name: Check for docker service
      ansible.builtin.command: systemctl is-active docker
      register: docker_service_check
      changed_when: false
      failed_when: false

    - name: Set docker_installed fact
      ansible.builtin.set_fact:
        docker_installed: "{{ docker_binary_check.stat.exists and docker_service_check.rc == 0 }}"
  rescue:
    - name: Set docker_installed fact to false if check fails
      ansible.builtin.set_fact:
        docker_installed: false

- name: Set default docker_installed fact when firewall is disabled
  when: not (iptables_manage_firewall | default(true))
  set_fact:
    docker_installed: false
  tags: [always]

- name: Configure firewall
  when: iptables_manage_firewall | default(true)
  tags: [configure, security, networking]
  block:
    - name: Install packages (ufw, iptables and at)
      become: true
      when: not ansible_check_mode
      ansible.builtin.package:
        name:
          - ufw
          - iptables
          - at
        state: present
      tags: [install]

    - name: Ensure /etc/iptables directory exists for saving rules (legacy)
      become: true
      when: not ansible_check_mode
      ansible.builtin.file:
        path: /etc/iptables
        state: directory
        mode: '0755'
      tags: [configure]

    - name: Install emergency firewall recovery script
      become: true
      when: not ansible_check_mode
      ansible.builtin.copy:
        src: emergency-iptables-recovery.sh
        dest: /usr/local/bin/emergency-iptables-recovery.sh
        mode: '0755'
      tags: [configure, safety]

    - name: Create ansible_port fact file for emergency script
      become: true
      when: not ansible_check_mode and (ansible_port | default(22) | int != 22)
      ansible.builtin.copy:
        content: "{{ ansible_port | default(22) }}"
        dest: /etc/ansible/facts.d/ansible_port.fact
        mode: '0644'
      tags: [configure, safety]

    - name: Install systemd unit for emergency firewall rollback (service)
      become: true
      when: not ansible_check_mode
      ansible.builtin.copy:
        src: emergency-iptables-recovery.service
        dest: /etc/systemd/system/emergency-iptables-recovery.service
        mode: '0644'

    - name: Install systemd unit for emergency firewall rollback (timer)
      become: true
      when: not ansible_check_mode
      ansible.builtin.template:
        src: emergency-iptables-recovery.timer.j2
        dest: /etc/systemd/system/emergency-iptables-recovery.timer
        mode: '0644'

    - name: Start emergency rollback timer
      become: true
      when: not ansible_check_mode
      ansible.builtin.systemd:
        name: emergency-iptables-recovery.timer
        state: started
        enabled: false
        daemon_reload: true
      tags: [configure, safety]

    - name: Show emergency recovery timer info
      when: not ansible_check_mode
      debug:
        msg: |
          SAFETY MECHANISM ACTIVATED:
          Emergency firewall rollback timer started: emergency-iptables-recovery.timer
          It will run in {{ iptables_emergency_recovery_delay_minutes | default(3) }} minutes to restore access if disconnected.
          The timer will be stopped at the end of this play if successful.
      tags: [validate, safety]

    - name: Ensure UFW is enabled with sane defaults
      become: true
      when: not ansible_check_mode
      community.general.ufw:
        state: enabled
        policy: deny
        direction: incoming
      tags: [configure]

    - name: Configure UFW forward policy for Docker networking
      become: true
      when: not ansible_check_mode and docker_installed
      community.general.ufw:
        state: enabled
        policy: allow
        direction: routed
      tags: [configure, docker]

    - name: Allow Docker bridge network forwarding
      become: true
      when: not ansible_check_mode and docker_installed
      ansible.builtin.command: "ufw allow out from {{ docker_source }} to any"
      loop: "{{ (iptables_docker_allowed_sources | default([])) + (iptables_docker_allowed_sources_extra | default([])) }}"
      loop_control:
        loop_var: docker_source
      tags: [configure, docker]

    - name: Allow return traffic from internet to Docker containers
      become: true
      when: not ansible_check_mode and docker_installed
      ansible.builtin.command: "ufw allow in from any to {{ docker_dest }}"
      loop: "{{ (iptables_docker_allowed_sources | default([])) + (iptables_docker_allowed_sources_extra | default([])) }}"
      loop_control:
        loop_var: docker_dest
      tags: [configure, docker]

    - name: Allow all traffic within private subnets (incoming)
      become: true
      when: not ansible_check_mode and (iptables_docker_allowed_sources | length) > 0
      ansible.builtin.command: "ufw allow in from {{ private_subnet }} to {{ private_subnet }}"
      loop: "{{ (iptables_docker_allowed_sources | default([])) + (iptables_docker_allowed_sources_extra | default([])) }}"
      loop_control:
        loop_var: private_subnet
      tags: [configure, networking]

    - name: Allow all traffic within private subnets (outgoing)
      become: true
      when: not ansible_check_mode and (iptables_docker_allowed_sources | length) > 0
      ansible.builtin.command: "ufw allow out from {{ private_subnet }} to {{ private_subnet }}"
      loop: "{{ (iptables_docker_allowed_sources | default([])) + (iptables_docker_allowed_sources_extra | default([])) }}"
      loop_control:
        loop_var: private_subnet
      tags: [configure, networking]

    - name: Allow UFW base ports
      become: true
      when: not ansible_check_mode and (ufw_custom_ports | length) > 0
      community.general.ufw:
        rule: allow
        port: "{{ item.port }}"
        proto: "{{ item.proto | default('tcp') }}"
      loop: "{{ ufw_custom_ports }}"
      tags: [configure]

    - name: Allow UFW custom ports (new API)
      become: true
      when: not ansible_check_mode and (ufw_custom_ports | length) > 0
      community.general.ufw:
        rule: allow
        port: "{{ item.port }}"
        proto: "{{ item.proto | default('tcp') }}"
      loop: "{{ ufw_custom_ports }}"
      tags: [configure]

    - name: Docker firewall (DOCKER-USER) configuration
      when: not ansible_check_mode and docker_installed and (iptables_enable_docker_chain | default(true) | bool)
      ansible.builtin.include_tasks: docker-firewall.yml
      tags: [docker, iptables]

    # Save rules is handled within docker-firewall tasks include

    # Ensure all Docker networks have MASQUERADE rules (defensive check)
    - name: Get current Docker networks for MASQUERADE validation
      when: not ansible_check_mode and docker_installed
      ansible.builtin.shell: |
        docker network ls --format "{{ '{{.Name}}' }}" | grep -v "^host$" | grep -v "^none$" | while read network; do
          subnet=$(docker network inspect "$network" --format '{{ "{{range .IPAM.Config}}{{.Subnet}}{{end}}" }}' 2>/dev/null || echo "")
          if [ ! -z "$subnet" ]; then
            echo "$network:$subnet"
          fi
        done
      register: current_docker_networks
      changed_when: false
      failed_when: false

    - name: Check each Docker network for missing MASQUERADE rules
      when: not ansible_check_mode and docker_installed and current_docker_networks.stdout_lines | length > 0
      ansible.builtin.shell: |
        network_info="{{ item }}"
        if [ ! -z "$network_info" ] && echo "$network_info" | grep -q ":"; then
          subnet=$(echo "$network_info" | cut -d: -f2)
          # Check if MASQUERADE rule exists for this subnet
          if ! iptables -t nat -C POSTROUTING -s "$subnet" -j MASQUERADE 2>/dev/null; then
            echo "$subnet"
          fi
        fi
      register: network_check_results
      changed_when: false
      failed_when: false
      loop: "{{ current_docker_networks.stdout_lines }}"

    - name: Add missing MASQUERADE rules for Docker networks
      when: not ansible_check_mode and docker_installed and network_check_results.results | map(attribute='stdout') | select('match', '^[0-9].*') | list | length > 0
      ansible.builtin.iptables:
        table: nat
        chain: POSTROUTING
        source: "{{ item }}"
        jump: MASQUERADE
        comment: "NAT for Docker network (auto-added)"
      loop: "{{ network_check_results.results | map(attribute='stdout') | select('match', '^[0-9].*') | list | unique }}"
      notify: commit iptables rules

    - name: Show MASQUERADE rule validation results
      when: not ansible_check_mode and docker_installed and current_docker_networks.stdout_lines | length > 0
      ansible.builtin.debug:
        msg: |
          Docker network MASQUERADE validation complete.
          Networks checked: {{ current_docker_networks.stdout_lines | length }}
          Missing rules fixed: {{ network_check_results.results | map(attribute='stdout') | select('match', '^[0-9].*') | list | length }}

    - name: Stop and disable emergency rollback timer (deployment succeeded)
      become: true
      when: not ansible_check_mode
      ansible.builtin.systemd:
        name: emergency-iptables-recovery.timer
        state: stopped
        enabled: false
      register: emergency_timer_stop
      tags: [cleanup, safety]

    - name: Confirm emergency job cancellation
      when: not ansible_check_mode
      debug:
        msg: |
          SUCCESS: Emergency rollback timer stopped.

          Your firewall configuration has been applied successfully without triggering emergency recovery.
      tags: [validate]
